# -*- makefile -*-
# 
# This file describes which puzzle binaries are made up from which
# object and resource files. It is processed into the various
# Makefiles by means of a Perl script. Makefile changes should
# really be made by editing this file and/or the Perl script, not
# by editing the actual Makefiles.

!name puzzles

!makefile gtk Makefile.gtk
!makefile am Makefile.am
!makefile vc Makefile.vc
!makefile wce Makefile.wce
!makefile cygwin Makefile.cyg
!makefile osx Makefile.osx
!makefile gnustep Makefile.gnustep
!makefile nestedvm Makefile.nestedvm
!makefile emcc Makefile.emcc
!makefile clangcl Makefile.clangcl

!srcdir icons/

WINDOWS_COMMON = printing
         + user32.lib gdi32.lib comctl32.lib comdlg32.lib winspool.lib
WINDOWS  = windows WINDOWS_COMMON
COMMON   = midend drawing misc malloc random version
GTK      = gtk printing ps
# Objects needed for auxiliary command-line programs.
STANDALONE = nullfe random misc malloc

ALL      = list

LATIN_DEPS   = matching tree234
LATIN        = latin LATIN_DEPS
LATIN_SOLVER = latin[STANDALONE_SOLVER] LATIN_DEPS

# First half of list.c.
!begin >list.c
/*
 * list.c: List of pointers to puzzle structures, for monolithic
 * platforms.
 *
 * This file is automatically generated by mkfiles.pl. Do not edit
 * it directly, or the changes will be lost next time mkfiles.pl runs.
 * Instead, edit Recipe and/or its *.R subfiles.
 */
#include "puzzles.h"
#define GAMELIST(A) \
!end

# Now each .R file adds part of the macro definition of GAMELIST to list.c.
!include *.R

# Then we finish up list.c as follows:
!begin >list.c

#define DECL(x) extern const game x;
#define REF(x) &x,
GAMELIST(DECL)
const game *gamelist[] = { GAMELIST(REF) };
const int gamecount = lenof(gamelist);
!end

# Unix standalone application for special-purpose obfuscation.
obfusc : [U] obfusc STANDALONE

# Test program built from latin.c.
latincheck : [U] latin[STANDALONE_LATIN_TEST] LATIN_DEPS STANDALONE
latincheck : [C] latin[STANDALONE_LATIN_TEST] LATIN_DEPS STANDALONE

# Test program built from matching.c.
matching : [U] matching[STANDALONE_MATCHING_TEST] tree234 STANDALONE
matching : [C] matching[STANDALONE_MATCHING_TEST] tree234 STANDALONE

puzzles  : [G] windows[COMBINED] WINDOWS_COMMON COMMON ALL noicon.res

# Mac OS X unified application containing all the puzzles.
Puzzles  : [MX] osx osx.icns osx-info.plist COMMON ALL
# For OS X, we must create the online help and include it in the
# application bundle.) Also we add -DCOMBINED to the compiler flags
# so as to inform the code that we're building a single binary for
# all the puzzles. Then I've also got some code in here to build a
# distributable .dmg disk image.
!begin osx
Puzzles_extra = Puzzles.app/Contents/Resources/Help/index.html
Puzzles.app/Contents/Resources/Help/index.html: \
	Puzzles.app/Contents/Resources/Help osx-help.but puzzles.but
	cd Puzzles.app/Contents/Resources/Help; \
		halibut --html ../../../../osx-help.but ../../../../puzzles.but
Puzzles.app/Contents/Resources/Help: Puzzles.app/Contents/Resources
	mkdir -p Puzzles.app/Contents/Resources/Help

release: Puzzles.dmg
Puzzles.dmg: Puzzles
	rm -f raw.dmg
	hdiutil create -megabytes 5 -layout NONE raw.dmg
	hdid -nomount raw.dmg > devicename
	newfs_hfs -v "Simon Tatham's Puzzle Collection" `cat devicename`
	hdiutil eject `cat devicename`
	hdid raw.dmg | cut -f1 -d' ' > devicename
	cp -R Puzzles.app /Volumes/"Simon Tatham's Puzzle Collection"
	hdiutil eject `cat devicename`
	rm -f Puzzles.dmg
	hdiutil convert -format UDCO raw.dmg -o Puzzles.dmg
	rm -f raw.dmg devicename
!end

!begin am
bin_PROGRAMS = $(GAMES)
!end
!begin am_begin
GAMES =
!end

# make install for Unix.
!begin gtk
install:
	for i in $(GAMES); do \
		$(INSTALL_PROGRAM) -m 755 $(BINPREFIX)$$i $(DESTDIR)$(gamesdir)/$(BINPREFIX)$$i \
		|| exit 1; \
	done
!end
!begin nestedvm
%.tmpdir/PuzzleEngine.class: %.mips
	mkdir -p $(patsubst %.mips,%,$<).tmpdir
	cd $(patsubst %.mips,%,$<).tmpdir && \
		java -cp $(NESTEDVM)/build:$(NESTEDVM)/upstream/build/classgen/build \
		org.ibex.nestedvm.Compiler -outformat class -d . \
		PuzzleEngine ../$<

org:
	mkdir -p org/ibex/nestedvm/util
	cp $(NESTEDVM)/build/org/ibex/nestedvm/Registers.class org/ibex/nestedvm
	cp $(NESTEDVM)/build/org/ibex/nestedvm/UsermodeConstants.class org/ibex/nestedvm
	cp $(NESTEDVM)/build/org/ibex/nestedvm/Runtime*.class org/ibex/nestedvm
	cp $(NESTEDVM)/build/org/ibex/nestedvm/util/Platform*.class org/ibex/nestedvm/util
	cp $(NESTEDVM)/build/org/ibex/nestedvm/util/Seekable*.class org/ibex/nestedvm/util

applet.manifest:
	echo "Main-Class: PuzzleApplet" >applet.manifest

PuzzleApplet.class: PuzzleApplet.java org
	javac -source 1.7 -target 1.7 PuzzleApplet.java

%.jar: %.tmpdir/PuzzleEngine.class PuzzleApplet.class applet.manifest org
	cd $(patsubst %.jar,%,$@).tmpdir && ln -s ../applet.manifest ../org ../PuzzleApplet*.class .
	cd $(patsubst %.jar,%,$@).tmpdir && jar cfm ../$@ applet.manifest PuzzleEngine.class PuzzleApplet*.class org
	echo '<applet archive="'$@'" code="PuzzleApplet" width="700" height="500"></applet>' >$*.html
!end

# A benchmarking and testing target for the GTK puzzles.
!begin gtk
test: benchmark.html benchmark.txt

benchmark.html: benchmark.txt benchmark.pl
	./benchmark.pl benchmark.txt > $@

benchmark.txt: benchmark.sh $(GAMES)
	./benchmark.sh > $@

!end
!begin am
test: benchmark.html benchmark.txt

benchmark.html: benchmark.txt benchmark.pl
	./benchmark.pl benchmark.txt > $@

benchmark.txt: benchmark.sh $(GAMES)
	./benchmark.sh > $@
!end
